# Design Document: `Viviphi` Library

**Status:** Draft v1.0
**Language:** Python 3.10+
**Output Format:** Standalone Animated SVG (CSS-driven)

## 1\. Executive Summary

The goal is to create a Python library that transforms static text-based graph definitions (Mermaid.js) into publication-quality, animated SVGs. Unlike standard renderers, this library focuses on **cinematic presentation**: nodes appearing sequentially, edges drawing themselves as if sketched live, and data flowing through connections.

Crucially, the output must be **"Zero-JS"**: all animations are driven by embedded CSS, ensuring the SVGs are safe to embed in GitHub READMEs, Notion, and strictly secured CMS environments.

## 2\. System Architecture

The architecture follows a **Headless Hybrid** pattern. We leverage the robustness of the official Mermaid JavaScript library for layout, but offload the rendering and animation logic to Python.

### The Pipeline

1.  **Input:** User provides a standard Mermaid string (e.g., `graph TD; A-->B`).
2.  **Layout Engine (The "Bridge"):** A lightweight headless browser (Playwright/Selenium) renders the graph to a static SVG. This ensures 100% syntax compatibility with Mermaid.
3.  **Python Post-Processor:**
      * **Parser:** `lxml` or `xml.etree` decomposes the static SVG.
      * **Geometry Engine:** `svgpathtools` analyzes edge paths to calculate precise pixel lengths.
      * **Injector:** Inserts CSS variables (`--length`, `--delay`) and filter definitions (Glow/Glassmorphism).
4.  **Output:** A single, portable `.svg` file.

## 3\. Detailed Design Decisions

### 3.1. The "Web-Friendly" Animation Mechanics

To satisfy the requirement of reusability, we avoid `<script>` tags entirely.

  * **Technique:** **Stroke-Dashoffset Interpolation**.
      * We set the `stroke-dasharray` of a line to its total length.
      * We set the `stroke-dashoffset` to equal the length (hiding the line).
      * A CSS `@keyframe` reduces the offset to `0`, revealing the line.
  * **The Challenge:** CSS cannot know the length of an SVG Path.
  * **The Solution:** Python calculates the integral of the Bezier curve and injects it as an inline style: `style="--length: 450.2px"`.

### 3.2. Visual Themes (The "Stunning" Factor)

The library will support a `Theme` object to decouple structure from style.

  * **Neon/Cyberpunk:** High-contrast strokes with `<feGaussianBlur>` duplicates behind the main stroke.
  * **Hand-Drawn:** Apply `stroke-linecap: round` and slightly randomize the animation speed.
  * **Corporate/Clean:** Flat colors with subtle opacity fades for nodes.

### 3.3. Topological Staggering

To prevent visual chaos, the graph shouldn't appear all at once.

  * **Algorithm:** The Python Processor will traverse the XML structure.
  * **Logic:** Elements appearing earlier in the DOM (usually higher up in the graph rank) get a lower `animation-delay`.
  * **Implementation:** `style="animation-delay: {index * 0.1}s"`

## 4\. Technical Implementation (Proof of Concept)

Below is the validated core logic for the **Animation Injector**. This module assumes the static SVG has already been generated by the Layout Engine.

### Core Dependencies

```bash
pip install svgpathtools
```

### The Processor Code

```python
import xml.etree.ElementTree as ET
from svgpathtools import parse_path

class SVGAnimator:
    def __init__(self, static_svg_content):
        # Register namespace to prevent ns0: prefixes in output
        ET.register_namespace('', "http://www.w3.org/2000/svg")
        self.root = ET.fromstring(static_svg_content)
        self.ns = {'svg': 'http://www.w3.org/2000/svg'}

    def _get_css_template(self):
        """Returns the CSS block for the animations."""
        return """
            /* Base Line Style */
            .anim-edge {
                stroke-dasharray: var(--length);
                stroke-dashoffset: var(--length);
                animation: draw-flow 1.5s ease-out forwards;
                opacity: 0.8;
            }
            
            /* The Draw Animation */
            @keyframes draw-flow {
                to { stroke-dashoffset: 0; }
            }
            
            /* Node Entrance Animation */
            .anim-node {
                opacity: 0;
                animation: fade-in 0.5s ease-out forwards;
            }
            
            @keyframes fade-in {
                to { opacity: 1; }
            }
            
            /* Glow Filter Effect */
            .neon-glow {
                filter: drop-shadow(0 0 5px var(--glow-color, #00ffcc));
            }
        """

    def process(self, color="#00ffcc"):
        # 1. Inject CSS
        style_el = ET.Element('style')
        style_el.text = self._get_css_template()
        self.root.insert(0, style_el)

        # 2. Process Paths (Edges)
        paths = self.root.findall('.//svg:path', self.ns)
        for i, path in enumerate(paths):
            d_string = path.get('d')
            if not d_string: continue

            try:
                # Calculate geometry using svgpathtools
                path_obj = parse_path(d_string)
                length = path_obj.length()
                
                # Logic: Nodes appear, then lines draw connecting them
                # Delay based on index to create "waterfall"
                delay = i * 0.3 
                
                existing_style = path.get('style', '')
                new_style = (
                    f"{existing_style}; "
                    f"--length: {length:.2f}; "
                    f"--glow-color: {color}; "
                    f"animation-delay: {delay}s;"
                )
                
                path.set('style', new_style)
                path.set('class', 'anim-edge neon-glow')
                
                # Enforce styling overrides for consistency
                path.set('stroke', color)
                path.set('fill', 'none')
                
            except Exception as e:
                print(f"Skipping complex path {i}: {e}")

        return ET.tostring(self.root, encoding='unicode')

# --- Usage Example ---
if __name__ == "__main__":
    # Mock input representing a Mermaid connector
    input_svg = """
    <svg width="400" height="200" xmlns="http://www.w3.org/2000/svg">
        <path d="M 50 150 Q 200 50 350 150" stroke="black" fill="none"/>
    </svg>
    """
    
    animator = SVGAnimator(input_svg)
    final_svg = animator.process(color="#ff0055")
    
    with open("animated_output.svg", "w") as f:
        f.write(final_svg)
```

## 5\. API Design Draft

The user-facing API should be clean and declarative.

```python
from mermaid_motion import Graph, Theme

# Define the Look
cyberpunk = Theme(
    primary_color="#00ff99",
    background="#1a1a1a",
    edge_style="neon",     # multiple strokes with blur
    node_style="glass"     # translucent fill with border
)

# Define the Content
g = Graph("graph TD; A[User] --> B{Login}; B --> C[Dashboard]")

# Render
g.animate(
    theme=cyberpunk, 
    speed="slow", 
    output="login_flow.svg"
)
```

## 6\. Future Considerations

1.  **Icon Mapping:** A dictionary mapping Mermaid node text (e.g., `[Database]`) to FontAwesome SVG paths to replace standard rectangles with actual icons.
2.  **Interactive Hover States:** Inject CSS `:hover` classes to highlight specific paths (e.g., hovering a node highlights all outgoing connections).
3.  **GIF Export:** Add an optional dependency (`cairosvg` + `imageio`) to rasterize the SVG animation into a GIF for platforms that don't support SVG animations (like LinkedIn).

-----
